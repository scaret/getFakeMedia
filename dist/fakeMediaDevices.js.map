{"version":3,"file":"fakeMediaDevices.js","mappings":"CAAA,SAA2CA,EAAMC,GAC1B,iBAAZC,SAA0C,iBAAXC,OACxCA,OAAOD,QAAUD,IACQ,mBAAXG,QAAyBA,OAAOC,IAC9CD,OAAO,GAAIH,GACe,iBAAZC,QACdA,QAA0B,iBAAID,IAE9BD,EAAuB,iBAAIC,IAR7B,CASGK,MAAM,WACT,M,mBCTA,IAAIC,EAAsB,CCA1BA,EAAwB,CAACL,EAASM,KACjC,IAAI,IAAIC,KAAOD,EACXD,EAAoBG,EAAEF,EAAYC,KAASF,EAAoBG,EAAER,EAASO,IAC5EE,OAAOC,eAAeV,EAASO,EAAK,CAAEI,YAAY,EAAMC,IAAKN,EAAWC,MCJ3EF,EAAwB,CAACQ,EAAKC,IAAUL,OAAOM,UAAUC,eAAeC,KAAKJ,EAAKC,GCClFT,EAAyBL,IACH,oBAAXkB,QAA0BA,OAAOC,aAC1CV,OAAOC,eAAeV,EAASkB,OAAOC,YAAa,CAAEC,MAAO,WAE7DX,OAAOC,eAAeV,EAAS,aAAc,CAAEoB,OAAO,M,qDCGvD,MAAMC,EAA0B,GCD1BC,EAAgBC,IAClB,IAAIC,EAAmC,KACvC,MAAMC,EAA0B,GAC1BC,EAA4B,GAClC,GAAIH,EAAWI,MAAM,CAIjB,MAAMC,GAAsC,IAArBL,EAAWI,MAAiB,GAAKJ,EAAWI,MACnEF,EAASI,KDNVC,eAA6BC,GAChC,MAAM,WACFC,EAAa,MACbD,EACEE,EAAU,IAAIC,aAAa,CAACF,WAAAA,IAElC,IAAIG,EADJd,EAASQ,KAAKI,GAEd,IACIE,EAAc,IAAIC,gCAAgCH,GACrD,MAAMI,GAEH,GAAe,cAAXA,EAAEC,KAGF,MAAMD,EAFNF,EAAcF,EAAQM,+BAK9B,GAAIR,EAAUS,YAAY,CACtB,MAAMC,EAAYV,EAAUS,YACxBT,EAAUS,YAAYE,MACtBT,EAAQU,gBAAgBF,EAAUC,MAAOE,IACrC,MAAMC,EAAcZ,EAAQa,qBAC5BC,QAAQC,IAAI,SAAUJ,GACtBC,EAAYD,OAASA,EACrBC,EAAYI,KAAOR,EAAUQ,KAC7BJ,EAAYK,QAAQf,GACpBU,EAAYM,WAKxB,OADmBhB,EAAYiB,OAAOC,iBAAiB,GCxBrCC,CAAc1B,GAAgB2B,MAAMC,IAC9ChC,EAAagC,EACb9B,EAAOG,KAAK2B,OAGpB,OAAOC,QAAQC,IAAIjC,GAAU8B,MAAK,IACvB,IAAII,YAAYjC,MAIzBkC,EAAS,O","sources":["webpack://[name]/webpack/universalModuleDefinition","webpack://[name]/webpack/bootstrap","webpack://[name]/webpack/runtime/define property getters","webpack://[name]/webpack/runtime/hasOwnProperty shorthand","webpack://[name]/webpack/runtime/make namespace object","webpack://[name]/./lib/audio/audio.ts","webpack://[name]/./lib/fakeMediaDevices.ts"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"fakeMediaDevices\"] = factory();\n\telse\n\t\troot[\"fakeMediaDevices\"] = factory();\n})(self, function() {\nreturn ","// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","export interface fakeAudioTrackConstraints{\n    sampleRate?: number;\n    audioBuffer?: {\n        data: ArrayBuffer;\n        loop: boolean;\n    }\n}\n\nconst contexts:AudioContext[] = [];\n\nexport async function getAudioTrack(constaint: fakeAudioTrackConstraints){\n    const {\n        sampleRate = 48000\n    } = constaint\n    const context = new AudioContext({sampleRate});\n    contexts.push(context);\n    let destination: MediaStreamAudioDestinationNode;\n    try{\n        destination = new MediaStreamAudioDestinationNode(context);\n    }catch(e){\n        //@ts-ignore\n        if (e.name === \"TypeError\"){\n            destination = context.createMediaStreamDestination();\n        }else{\n            throw e;\n        }\n    }\n    if (constaint.audioBuffer){\n        const mp3Buffer = constaint.audioBuffer;\n        if (constaint.audioBuffer.data){\n            context.decodeAudioData(mp3Buffer.data, (buffer:AudioBuffer)=>{\n                const audioSource = context.createBufferSource()\n                console.log(\"buffer\", buffer);\n                audioSource.buffer = buffer;\n                audioSource.loop = mp3Buffer.loop;\n                audioSource.connect(destination);\n                audioSource.start()\n            })\n        }\n    }\n    const audioTrack = destination.stream.getAudioTracks()[0];\n    return audioTrack;\n}\n\nexport async function resumeAudio(){\n    contexts.forEach((ctx)=>{\n        ctx.resume()\n    })\n}","import {fakeAudioTrackConstraints, getAudioTrack} from \"./audio/audio\";\n\n\ninterface fakeMediaStreamConstraints{\n    audio: boolean|fakeAudioTrackConstraints\n}\n\nconst getFakeMedia = (constrants: fakeMediaStreamConstraints)=>{\n    let audioTrack:MediaStreamTrack|null = null\n    const promises:Promise<any>[] = [];\n    const tracks:MediaStreamTrack[] = [];\n    if (constrants.audio){\n        // promises.push(getAudioTrack().then((track)=>{\n        //     audioTrack = track\n        // }))\n        const audioConstaint = constrants.audio === true ? {} : constrants.audio;\n        promises.push(getAudioTrack(audioConstaint).then((track)=>{\n            audioTrack = track;\n            tracks.push(track)\n        }))\n    }\n    return Promise.all(promises).then(()=>{\n        return new MediaStream(tracks)\n    })\n}\n\nconst resume = ()=>{\n\n}\n\nexport {\n    getFakeMedia,\n    resume,\n}"],"names":["root","factory","exports","module","define","amd","self","__webpack_require__","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","Symbol","toStringTag","value","contexts","getFakeMedia","constrants","audioTrack","promises","tracks","audio","audioConstaint","push","async","constaint","sampleRate","context","AudioContext","destination","MediaStreamAudioDestinationNode","e","name","createMediaStreamDestination","audioBuffer","mp3Buffer","data","decodeAudioData","buffer","audioSource","createBufferSource","console","log","loop","connect","start","stream","getAudioTracks","getAudioTrack","then","track","Promise","all","MediaStream","resume"],"sourceRoot":""}